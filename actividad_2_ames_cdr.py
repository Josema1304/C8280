# -*- coding: utf-8 -*-
"""Actividad 2 - Ames - CDR

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1foCgWIyRRhOdg3gFHPkZFexnxH4DPE8v

MATPLOTLIB

En el diagrama anterior, la figura se considera la figura actual. Cualquier otra función que usemos o apliquemos, como la función plt.ylabel, colocaría una etiqueta en el eje y que se conoce como ylabel. La etiqueta, en este caso, son algunos números. Vuelve a ejecutar y visualiza el resultado, en el que podemos ver cómo se aplica esta función.
"""

import matplotlib.pyplot as plt

# Crear una figura y una subtrama
fig, ax = plt.subplots()

# Traza los datos en el subtrazado
ax.plot([1, 2, 3, 2.5])

# Añadir una etiqueta al eje y-axis
plt.ylabel('Numbers')

# Mostrar la figura
plt.show()

"""La función más utilizada en la interfaz de pyplot es la función plot, que puede tomar muchos argumentos. Por ejemplo, si pasamos dos listas de números, asumirá que la primera lista son las coordenadas x y la segunda lista son las coordenadas y, trazando una línea por defecto."""

import matplotlib.pyplot as plt

x = [1, 2, 3, 4]
y = [1, 2, 3, 2.5]

fig, ax = plt.subplots()
ax.plot(x, y)
plt.show()

"""Escribe un script para dibujar esto en diferentes subplots."""

import matplotlib.pyplot as plt
import numpy as np

# Values of x
x = np.linspace(start=-5, stop=5, num=150)

# Create a figure and subplots
fig, axs = plt.subplots(2, 2, figsize=(10, 8))
fig.suptitle('Powers of x', fontsize=16)

# Plot powers of x on different subplots
axs[0, 0].plot(x, x)
axs[0, 0].set_title('Linear')

axs[0, 1].plot(x, x**2)
axs[0, 1].set_title('Quadratic')

axs[1, 0].plot(x, x**3)
axs[1, 0].set_title('Cubic')

axs[1, 1].plot(x, x**4)
axs[1, 1].set_title('4th power')

# Adjust spacing and display the figure
plt.tight_layout()
plt.show()

"""Escribe una script para dibujar a las primeras diez potencias de x con un título que diga x hasta N, donde N=1, . . .,10."""

import matplotlib.pyplot as plt
import numpy as np

# Values of x
x = np.linspace(start=-5, stop=5, num=150)

# Create a figure and subplots
fig, axs = plt.subplots(2, 5, figsize=(12, 6))
fig.suptitle('Powers of x', fontsize=16)

# Iterate through powers and plot on subplots
for i, power in enumerate(range(1, 11)):
    row = i // 5
    col = i % 5
    axs[row, col].plot(x, x ** power)
    axs[row, col].set_title(f'x up to {power}')

# Adjust spacing and display the figure
plt.tight_layout()
plt.show()

"""Ejercicio Supongamos que deseas que las etiquetas del eje x aparezcan en notaciones matemáticas como -pi y -pi/2. Escribe un script utilizando los métodos set_xticks, set_yticks, set_xticklabels y set_yticklabels para cambiar y asignar nuevos valores."""

import matplotlib.pyplot as plt
import numpy as np

# Values of x
x = np.linspace(start=-np.pi, stop=np.pi, num=200)
sine = np.sin(x)
cosine = np.cos(x)

# Create a figure and subplot
fig, ax = plt.subplots()

# Plot sine and cosine
ax.plot(x, sine, color='red')
ax.plot(x, cosine, color='#165181')

# Set x-axis and y-axis limits
ax.set_xlim(-3.5, 3.5)
ax.set_ylim(-1.2, 1.2)

# Set custom tick locations and labels for x-axis
xticks = [-np.pi, -np.pi/2, 0, np.pi/2, np.pi]
xticklabels = [r'$-\pi$', r'$-\frac{\pi}{2}$', '0', r'$\frac{\pi}{2}$', r'$\pi$']
ax.set_xticks(xticks)
ax.set_xticklabels(xticklabels)

# Set custom tick locations and labels for y-axis
yticks = np.arange(-1, 1.1, 0.5)
yticklabels = [f'${tick}$' for tick in yticks]
ax.set_yticks(yticks)
ax.set_yticklabels(yticklabels)

# Display the figure
plt.show()

"""Agrega la etiqueta de las funciones seno y coseno ubicada en la parte superior izquierda del gráfico, donde podemos identificar fácilmente cada línea por el nombre."""

import matplotlib.pyplot as plt
import numpy as np

# Values of x
x = np.linspace(start=-np.pi, stop=np.pi, num=200)
sine = np.sin(x)
cosine = np.cos(x)

# Create a figure and subplot
fig, ax = plt.subplots()

# Plot sine and cosine
ax.plot(x, sine, color='red', label='Sine')
ax.plot(x, cosine, color='#165181', label='Cosine')

# Set x-axis and y-axis limits
ax.set_xlim(-3.5, 3.5)
ax.set_ylim(-1.2, 1.2)

# Set custom tick locations and labels for x-axis
xticks = [-np.pi, -np.pi/2, 0, np.pi/2, np.pi]
xticklabels = [r'$-\pi$', r'$-\frac{\pi}{2}$', '0', r'$\frac{\pi}{2}$', r'$\pi$']
ax.set_xticks(xticks)
ax.set_xticklabels(xticklabels)

# Set custom tick locations and labels for y-axis
yticks = np.arange(-1, 1.1, 0.5)
yticklabels = [f'${tick}$' for tick in yticks]
ax.set_yticks(yticks)
ax.set_yticklabels(yticklabels)

# Add labels for sine and cosine
ax.text(-3, 1, 'Sine', color='red', fontsize=12)
ax.text(-3, 0.85, 'Cosine', color='#165181', fontsize=12)

# Display the figure
plt.show()

"""Hay dos funciones o métodos principales para realizar anotaciones en un gráfico. Puedes usar el método text() especificando la coordenada x y la coordenada y donde deseas que se muestre el texto, y el tercer argumento para este método es el texto que realmente deseas dibujar en el gráfico. Explica el resultado siguiente resultado:

fig, ax = plt.subplots()
ax.plot(x, seno, color='green', label='Seno')
ax.plot(x, coseno, color='#341161', label='Coseno')

ax.set_xlim(-3.5,3.5)
ax.set_ylim(-1.2,1.2)

ax.set_xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])
ax.set_yticks([-1,0,1])

ax.set_xticklabels([r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'], size=17)
ax.set_yticklabels(['-1','0','+1'], size=17)

ax.legend(loc='upper left')

ax.text(-0.25,0,'(0,0)')
ax.text(np.pi-0.25,0, r'$(\pi,0)$', size=15)

ax.annotate('Origen',
            xy=(0, 0),
            xytext=(1, -0.7),
            arrowprops=dict(facecolor='blue'));

El código proporcionado genera un gráfico que muestra las funciones seno y coseno e incluye varias anotaciones y opciones de formato. Repasemos los distintos componentes y expliquemos sus efectos:

1. 1. `fig, ax = plt.subplots()` crea una figura y un único subplot.

2. ax.plot(x, sine, color='green', label='Sine')` representa la función seno utilizando los valores de las matrices `x` y `sine`. El color de la línea se establece en verde, y la etiqueta se establece como `Seno`.

3. 3. `ax.plot(x, cosine, color='#341161', label='Cosine')` representa la función coseno utilizando los valores de las matrices `x` y `cosine`. El color de la línea se establece en un tono específico de púrpura (`#341161`), y la etiqueta se establece como `Coseno`.

4. `ax.set_xlim(-3.5,3.5)` y `ax.set_ylim(-1.2,1.2)` fijan los límites de los ejes x e y, respectivamente.

5. `ax.set_xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi])` y `ax.set_yticks([-1,0,1])` fijan las posiciones de las marcas de graduación en los ejes x e y, respectivamente.

6. 6. `ax.set_xticklabels([r'$-pi$', r'$-pi/2$', r'$0$', r'$+pi/2$', r'$+pi$'], size=17)` y `ax.set_yticklabels(['-1','0','+1'], size=17)` fijan las etiquetas de las marcas en el eje x y en el eje y, respectivamente. Las etiquetas se formatean utilizando notación LaTeX y se muestran con un tamaño de fuente de 17.

7. 7. `ax.legend(loc='upper left')` muestra una leyenda en la esquina superior izquierda del gráfico, que incluye las etiquetas 'Seno' y 'Coseno' junto con sus correspondientes colores de línea.

8. 8. `ax.text(-0.25,0,'(0,0)')` añade una anotación de texto en la coordenada (-0.25, 0) del gráfico. La anotación muestra el texto '(0,0)'.

9. 9. `ax.text(np.pi-0.25,0, r'$(pi,0)$', size=15)` añade otra anotación de texto en la coordenada (π-0.25, 0) del gráfico. La anotación muestra el texto 'π,0' utilizando notación LaTeX.

10. 10. `ax.annotate('Origen', xy=(0, 0), xytext=(1, -0.7), arrowprops=dict(facecolor='azul'))` añade una anotación con una flecha apuntando al texto. El texto 'Origen' se coloca en la coordenada (0, 0), y el texto de la anotación aparece en la coordenada (1, -0,7). La flecha es de color azul.

El gráfico resultante mostrará las funciones seno y coseno, etiquetadas en la leyenda, con etiquetas de marca personalizadas en los ejes x e y. También habrá anotaciones indicando el origen y puntos específicos en el gráfico.

Realiza lo siguiente:

Genera una muestra de 100 valores de datos espaciados uniformemente de 0 a 50
Personaliza las etiquetas de los ejes, con nombres como, Etiquetas muestrales etiqueta x en los ejes, etiqueta y en los ejes.
Agrega la leyenda y utiliza tight_layout() el padding adicional alrededor del borde de la figura y entre los subplots.
"""

# Generar la muestra de datos
x = np.linspace(0, 50, 100)
y = np.random.rand(100)

# Crear la figura y los ejes
fig, ax = plt.subplots()

# Graficar los datos
ax.plot(x, y, label='Datos')

# Personalizar las etiquetas de los ejes
ax.set_xlabel('Etiqueta x en los ejes')
ax.set_ylabel('Etiqueta y en los ejes')

# Agregar la leyenda
ax.legend()

# Ajustar el espacio en el gráfico
fig.tight_layout()

# Mostrar el gráfico
plt.show()

"""NUMPY"""

from __future__ import division
import time
import numpy as np

tam_vec = 1000

def list_python():
    t1 = time.time()
    X = range(tam_vec)
    Y = range(tam_vec)
    Z = []
    for i in range(len(X)):
        Z.append(X[i] + Y[i])
    return time.time() - t1

def array_numpy():
    t1 = time.time()
    X = np.arange(tam_vec)
    Y = np.arange(tam_vec)
    Z = X + Y
    return time.time() - t1

# Test the functions
print("List Python:", list_python())
print("NumPy Array:", array_numpy())

# Check NumPy version
print("NumPy version:", np.__version__)

import numpy as np

# Let's create a 3x3 array of all zeros
a = np.zeros((3,3))
print(a)

# We create a 2x2 array of all 1's
b = np.ones((2,2))
print(b)

# We create a constant 3x3 matrix
c = np.full((3,3), 7)
print(c)

# Create a 3x3 matrix with random values
d = np.random.random((3,3))
print(d)

# Create a 3x3 identity matrix
e = np.eye(3)
print(e)

# Convert a list to an array
f = np.array([2, 3, 1, 0])
print(f)

# arange() creates arrays with regularly incrementing values
# Mixing tuple and lists
g = np.array([(1,2,3), [4,5,6]])
print(g)

# create a range array with floating data type
i = np.arange(1, 8, dtype=np.float64)
print(i)

# linspace() creates arrays with a specified number of elements that are equally spaced between the specified start and end values
j = np.linspace(0, 1, 5)
print(j)

import numpy as np

np.random.seed(0)

x1 = np.random.randint(10, size=6)  # 1-d matrix
x2 = np.random.randint(10, size=(5, 4))  # array-2d
x3 = np.random.randint(10, size=(2, 4, 5))  # matriz-3d

# Print attributes: dim, shape, size, dtype, itemsize, and nbytes
print("x1 - 1D Array:")
print("Dimension:", x1.ndim)
print("Shape:", x1.shape)
print("Size:", x1.size)
print("Data Type:", x1.dtype)
print("Item Size (bytes):", x1.itemsize)
print("Total Size (bytes):", x1.nbytes)

print()

print("x2 - 2D Array:")
print("Dimension:", x2.ndim)
print("Shape:", x2.shape)
print("Size:", x2.size)
print("Data Type:", x2.dtype)
print("Item Size (bytes):", x2.itemsize)
print("Total Size (bytes):", x2.nbytes)

print()

print("\nx3:")
print("Dimensión:", x3.ndim)
print("Forma:", x3.shape)
print("Tamaño:", x3.size)
print("Tipo de datos:", x3.dtype)
print("Tamaño de cada elemento (en bytes):", x3.itemsize)
print("Tamaño total de la matriz (en bytes):", x3.nbytes)

import numpy as np

x = np.array([5, 6, 7, 8, 9])

# Slicing using start, end, and step
print(x[1:7:2])

# Slicing using negative indices
print(x[-2:5])
print(x[-1:1:-1])

# Slicing with default values
print(x[4:])

# Slicing using ellipsis
print(x[..., 0])

import numpy as np

x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Slicing with fewer objects in the selection tuple
print(x[1])  # Equivalent to x[1, :]
print(x[1:])  # Equivalent to x[1:, :]
print(x[:, 1])  # Slicing along the second dimension

# Using ellipsis to expand the selection tuple
print(x[..., 0])  # Equivalent to x[:, :, 0]

import numpy as np

# Create a rank 2 matrix with dimensions (3, 4)
matrix = np.array([[1, 2, 3, 4],
                   [5, 6, 7, 8],
                   [9, 10, 11, 12]])

# Extract the submatrix consisting of the first 2 rows and columns 1 and 2
submatrix = matrix[:2, 1:3]

print("Original Matrix:")
print(matrix)
print()

print("Submatrix:")
print(submatrix)
print()

# Modify the submatrix
submatrix[0, 0] = 99

print("Modified Submatrix:")
print(submatrix)
print()

print("Original Matrix (after modification):")
print(matrix)

import numpy as np

a = np.array([[1, 2], [3, 4]])

# Indexing an integer array
indices = np.array([0, 1])
result = a[indices, indices]

print(result)

import numpy as np

a = np.array([[1, 2], [3, 4]])

# Indexing an integer array
indices = np.array([0, 0])
result = a[indices, [1, 1]]

print(result)

import numpy as np

x4 = np.arange(1, 10).reshape((3, 3))
print(x4)

x5 = np.array([1, 2, 3])
print(x5)

# Row vector via reshape
row_vector_reshape = x5.reshape((1, x5.shape[0]))
print(row_vector_reshape)

# Row vector with newaxis
row_vector_newaxis = x5[np.newaxis, :]
print(row_vector_newaxis)

# Column vector via reshape
column_vector_reshape = x5.reshape((x5.shape[0], 1))
print(column_vector_reshape)

# Column vector with newaxis
column_vector_newaxis = x5[:, np.newaxis]
print(column_vector_newaxis)

x = np.array([4, 5, 6])
y = np.array([7, 8, 9])
np.concatenate([x, y])
# concatenacion de dos o mas matrices
z = [99, 99, 99]
print(np.concatenate([x, y, z]))
# concatendo una matriz dos veces
grid = np.array([[1, 2, 3],
                 [4, 5, 6]])
np.concatenate([grid, grid])

x = np.array([0, 1, 2])
grid = np.array([[3, 4, 5],
                 [6, 5, 4]])

# Se junta la matriz de manera vertical
vertical_stack = np.vstack([x, grid])
print(vertical_stack)

# Se junta la matriz de manera horizontal
y = np.array([[23],
              [23]])
horizontal_stack = np.hstack([grid, y])
print(horizontal_stack)

rand = np.random.RandomState(42)
x = rand.randint(100, size=10)
print(x)
# Accedemos a tres elementos diferentes
[x[1], x[5], x[2]]

import numpy as np

rand = np.random.RandomState(42)
x = rand.randint(100, size=10)
print(x)

# We access three different elements
print([x[1], x[5], x[2]])

# Alternatively, we can pass a single list or index array to get the same result
indices = [1, 5, 2]
print(x[indices])

import numpy as np

# When fancy indexing is used, the shape of the result reflects the shape of the index arrays
X = np.arange(12).reshape((3, 4))
print(X)

fila = np.array([0, 1, 2])
col = np.array([2, 1, 3])
X[fila, col]

X = np.arange(12).reshape((3, 4))
print(X)

fila = np.array([0, 1, 2])[:, np.newaxis]
col = np.array([2, 1, 3])
result = X[fila, col]
print(result)

import numpy as np

X = np.arange(12).reshape((3, 4))

# Combining fancy indexing and simple indexes
combined_indices = np.array([0, 2])
result1 = X[combined_indices, 1]
print(result1)

# Combining fancy indexing and slicing
combined_indices = np.array([0, 2])
sliced_result = X[combined_indices, 1:3]
print(sliced_result)

x = np.arange(10)
i = np.array([2, 1, 8, 4])
x[i] = 99
print(x)

x = np.zeros(10)
x[[0, 0]] = [4, 6]
print(x)

import numpy as np

x = np.zeros(5)
i = np.array([2, 3, 3, 4, 4, 4])

# Using at() method of ufuncs
np.add.at(x, i, 1)
print(x)

i = [2, 3, 3, 4, 4, 4]
x[i] += 1
x

x = np.array([0, 1, 2, 3, 4])
i = [2, 3, 3, 4, 4, 4]

np.add.at(x, i, 1)
print(x)

import numpy as np

a = np.array([0, 1, 2])
b = np.array([2, 6, 1])

# Element-wise addition of arrays
result1 = a + b
print(result1)

# Broadcasting a scalar value to an array
result2 = a + 5
print(result2)

A = np.arange(16).reshape(4, 4)
b = np.arange(4)

# Broadcasting a one-dimensional array to a two-dimensional array
result3 = A + b
print(result3)

# Broadcasting two matrices
C = np.ones((3, 3))
D = np.arange(3)

result4 = C + D[:, np.newaxis]
print(result4)

import numpy as np

a1 = np.array([1, 2, 3, 3, 4])
b1 = np.array([4, 3, 2, 2, 1])

# Element-wise comparison of arrays
result1 = a1 < b1
print(result1)

# Check if all elements in a1 are less than the elements in b1
result2 = np.all(a1 < b1)
print(result2)

# Check if any element in a1 is less than the elements in b1
result3 = np.any(a1 < b1)
print(result3)

if np.all(a1 < b1):
    print("All elements in a1 are less than the elements in b1.")
elif np.any(a1 < b1):
    print("Some elements in a1 are less than the elements in b1.")
else:
    print("All elements in b1 are less than the elements in a1.")

# Boolean array used in arithmetic expression
boolean_array = np.array([True, False, True])
numeric_array = boolean_array * 2
print(numeric_array)

# Defining a function using conditional computation
def pulse(t, position, height, width):
    return height * (t >= position) * (t <= (position + width))

# Testing the pulse function
t = np.linspace(0, 10, 100)
position = 3
height = 2
width = 2
output = pulse(t, position, height, width)
print(output)

k = np.array([1, 3, -1, 5, 7, -1])
mask = (k < 0)
mask

import numpy as np

rng = np.random.RandomState(0)
z1 = rng.randint(10, size=(3, 4))
print(z1)

import numpy as np

k = np.array([1, 3, -1, 5, 7, -1])
mask = (k < 0)
masked_values = k[mask]
print(masked_values)

import numpy as np

# A two-dimensional example
rng = np.random.RandomState(0)
z1 = rng.randint(10, size=(3, 4))
print(z1)

# Create a masking matrix
mask = (z1 % 2 == 0)

# Sum the masking matrix
sum_mask = np.sum(mask)
print(sum_mask)